<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Womba Tricking - 3D Experience</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Exo+2:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-glow: #3b82f6;
      --secondary-glow: #8b5cf6;
      --card-bg: rgba(17, 24, 39, 0.7);
    }
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Exo 2', sans-serif;
      background-color: #000;
      color: #e5e7eb;
    }
    #webgl-canvas {
      position: fixed;
      top: 0;
      left: 0;
      outline: none;
    }
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      text-align: center;
      cursor: pointer;
      z-index: 100;
      transition: opacity 0.5s;
    }
    #overlay h1 {
        font-size: 4rem;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        text-shadow: 0 0 15px var(--primary-glow), 0 0 30px var(--primary-glow);
        animation: glitch 2.5s linear infinite;
    }
    #overlay p {
        margin-top: 1rem;
        font-size: 1.2rem;
    }
    kbd {
        display: inline-block;
        padding: 0.2rem 0.5rem;
        background-color: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 4px;
        font-family: monospace;
        font-weight: bold;
    }
    @keyframes glitch {
      2%,64% { transform: translate(2px,0) skew(0deg); }
      4%,60% { transform: translate(-2px,0) skew(0deg); }
      62% { transform: translate(0,0) skew(5deg); }
    }
    .hud {
        position: fixed;
        color: white;
        pointer-events: none;
        width: 100%;
        height: 100%;
        z-index: 10;
    }
    .crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 4px;
        height: 4px;
        background-color: rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .crosshair.interactive {
        transform: translate(-50%, -50%) scale(2.5);
        background-color: rgba(139, 92, 246, 0.9);
    }
    .interaction-prompt {
        position: absolute;
        bottom: 10%;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0,0,0,0.5);
        padding: 0.5rem 1rem;
        border-radius: 8px;
        font-size: 1rem;
        opacity: 0;
        transition: opacity 0.3s;
        border: 1px solid rgba(255,255,255,0.2);
    }
    .interaction-prompt.visible {
        opacity: 1;
    }
    
    /* Modal styles */
    .modal-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        z-index: 200;
    }
    .modal-container.visible {
        opacity: 1;
        pointer-events: auto;
    }
    .modal-content {
        background-color: var(--card-bg);
        backdrop-filter: blur(12px);
        border: 1px solid var(--secondary-glow);
        border-radius: 12px;
        width: 90%;
        max-width: 800px;
        height: 80%;
        max-height: 700px;
        padding: 2rem;
        overflow-y: auto;
        transform: scale(0.95);
        transition: transform 0.3s ease;
        box-shadow: 0 0 40px rgba(139, 92, 246, 0.3);
        position: relative;
        overflow-x: hidden;
    }
    .modal-content::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(to bottom, rgba(255,255,255,0) 0%, rgba(255,255,255,0.03) 50%, rgba(255,255,255,0) 100%);
        background-size: 100% 4px;
        animation: scanlines 10s linear infinite;
        pointer-events: none;
    }
    @keyframes scanlines {
        from { background-position: 0 0; }
        to { background-position: 0 -40px; }
    }
    .modal-container.visible .modal-content {
        transform: scale(1);
    }
    .modal-content::-webkit-scrollbar { width: 6px; }
    .modal-content::-webkit-scrollbar-track { background: transparent; }
    .modal-content::-webkit-scrollbar-thumb { background: var(--secondary-glow); border-radius: 3px; }

    .modal-close-btn {
        position: absolute;
        top: 1rem; right: 1rem;
        background: rgba(255,255,255,0.1);
        border-radius: 50%;
        width: 32px; height: 32px;
        display: flex; align-items: center; justify-content: center;
        color: #fff;
        border: 1px solid rgba(255,255,255,0.2);
        transition: all 0.2s;
        z-index: 10;
    }
    .modal-close-btn:hover {
        background: var(--secondary-glow);
        transform: rotate(90deg);
    }
    .section-title {
        background: linear-gradient(90deg, #fff, #aaa);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        filter: drop-shadow(0 0 10px var(--primary-glow));
        font-size: 2.5rem;
        font-weight: bold;
        text-align: center;
        margin-bottom: 2rem;
    }
    .card {
        background: rgba(255,255,255,0.05);
        border-radius: 8px;
        padding: 1.5rem;
        margin-bottom: 1rem;
        border: 1px solid rgba(255,255,255,0.1);
    }
     .get-difficulty-class {
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        font-size: 0.75rem;
        font-weight: 600;
        display: inline-block;
        white-space: nowrap;
     }
    .difficulty-Новичок { background-color: rgba(74, 222, 128, 0.2); color: #86efac; border: 1px solid rgba(74, 222, 128, 0.3); }
    .difficulty-Средний { background-color: rgba(96, 165, 250, 0.2); color: #93c5fd; border: 1px solid rgba(96, 165, 250, 0.3); }
    .difficulty-Продвинутый, .difficulty-Средний\/Продвинутый { background-color: rgba(248, 113, 113, 0.2); color: #fca5a5; border: 1px solid rgba(248, 113, 113, 0.3); }
    .difficulty-Все, .difficulty-Все_уровни { background-color: rgba(139, 92, 246, 0.2); color: #c4b5fd; border: 1px solid rgba(139, 92, 246, 0.3); }

    .css2d-label {
        color: #fff;
        font-size: 24px;
        font-weight: 600;
        padding: 10px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 5px;
        text-shadow: 0 0 5px var(--secondary-glow);
        pointer-events: none;
    }

    /* Mobile Controls */
    #mobile-controls.hidden { display: none; }
    .joystick-zone {
        position: absolute;
        width: 150px;
        height: 150px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.2);
        pointer-events: auto;
    }
    .joystick-handle {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 60px;
        height: 60px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: transform 0.1s;
    }
    .mobile-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: white;
        font-size: 24px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        user-select: none;
        -webkit-user-select: none;
    }
    .mobile-btn:active {
        background: rgba(255, 255, 255, 0.4);
    }
    .interact-btn-main {
        position: absolute;
        bottom: 25%;
        left: 50%;
        transform: translateX(-50%);
        width: auto;
        padding: 15px 25px;
        border-radius: 30px;
        font-size: 16px;
        font-weight: 600;
        background-color: var(--secondary-glow);
        border: none;
        box-shadow: 0 0 20px var(--secondary-glow);
    }
    .interact-btn-main.hidden {
      display: none;
    }

    /* Responsive adjustments */
    @media (hover: none) and (pointer: coarse) {
        #desktop-keys { display: none; }
        #mobile-instructions { display: block !important; }
        .interaction-prompt { display: none; }
        .crosshair { display: none; }
    }

  </style>
</head>
<body>
  <div id="overlay">
    <h1>WOMBA</h1>
    <p id="overlay-prompt">Кликните, чтобы войти в 3D-пространство</p>
    <div id="desktop-keys" class="mt-8 text-gray-400 space-y-2">
        <p><kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> - Горизонтальное движение</p>
        <p><kbd>Space</kbd> / <kbd>Shift</kbd> - Вверх / Вниз</p>
        <p><kbd>Мышь</kbd> - Осмотр</p>
    </div>
    <div id="mobile-instructions" class="hidden mt-8 text-gray-400 space-y-2">
        <p>Используйте левый джойстик для движения</p>
        <p>Проведите по правой части экрана для осмотра</p>
        <p>Используйте кнопки для полета вверх/вниз</p>
    </div>
  </div>

  <div class="hud">
    <div class="crosshair"></div>
    <div class="interaction-prompt"><span id="interaction-text"></span> [<kbd>E</kbd>]</div>
  </div>
  
  <div id="modal-container" class="modal-container">
      <div id="modal-content" class="modal-content">
          <!-- Content will be injected here -->
      </div>
  </div>

  <div id="mobile-controls" class="hidden">
    <div id="joystick-move-zone" class="joystick-zone" style="left: 20px; bottom: 20px;">
        <div id="joystick-move-handle" class="joystick-handle"></div>
    </div>
    <div id="action-buttons" style="position: absolute; right: 20px; bottom: 20px; display: flex; flex-direction: column; gap: 15px;">
        <button id="move-up-btn" class="mobile-btn">▲</button>
        <button id="move-down-btn" class="mobile-btn">▼</button>
    </div>
    <button id="interact-btn" class="mobile-btn interact-btn-main hidden">Взаимодействовать</button>
  </div>


  <canvas id="webgl-canvas"></canvas>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0025);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.z = 10;
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('webgl-canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Optimization: Cap pixel ratio
    renderer.toneMapping = THREE.ReinhardToneMapping;

    // --- CSS2D Renderer for labels ---
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0px';
    labelRenderer.domElement.style.pointerEvents = 'none';
    document.body.appendChild(labelRenderer.domElement);

    // --- Post-processing (Bloom) ---
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.1; // Optimization: Increased threshold
    bloomPass.strength = 0.7; // Optimization: Reduced bloom strength
    bloomPass.radius = 0.35; // Optimization: Reduced bloom radius
    const composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // --- Controls ---
    let controls;
    const overlay = document.getElementById('overlay');
    if (isMobile) {
        document.getElementById('mobile-controls').classList.remove('hidden');
        document.getElementById('overlay-prompt').textContent = 'Нажмите, чтобы войти в 3D-пространство';
        document.getElementById('mobile-instructions').classList.remove('hidden');
    } else {
        controls = new PointerLockControls(camera, renderer.domElement);
        controls.addEventListener('lock', () => {
          overlay.style.opacity = '0';
          overlay.style.pointerEvents = 'none';
        });
        controls.addEventListener('unlock', () => {
          overlay.style.opacity = '1';
          overlay.style.pointerEvents = 'auto';
        });
        scene.add(controls.getObject());
    }
     overlay.addEventListener('click', () => {
        if(isMobile) {
            overlay.style.opacity = '0';
            overlay.style.pointerEvents = 'none';
        } else {
            controls.lock();
        }
    });


    // --- Movement ---
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
    let cameraLookSpeed = { x: 0, y: 0 };
    
    const onKeyDown = (event) => {
      switch (event.code) {
        case 'KeyW': case 'ArrowUp': moveForward = true; break;
        case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
        case 'KeyS': case 'ArrowDown': moveBackward = true; break;
        case 'KeyD': case 'ArrowRight': moveRight = true; break;
        case 'Space': moveUp = true; break;
        case 'ShiftLeft': case 'KeyC': moveDown = true; break;
        case 'KeyE': if (intersectedObject) openModalForObject(intersectedObject); break;
        case 'Escape': if (modalContainer.classList.contains('visible')) closeModal(); else if (!isMobile) controls.unlock(); break;
      }
    };
    const onKeyUp = (event) => {
      switch (event.code) {
        case 'KeyW': case 'ArrowUp': moveForward = false; break;
        case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
        case 'KeyS': case 'ArrowDown': moveBackward = false; break;
        case 'KeyD': case 'ArrowRight': moveRight = false; break;
        case 'Space': moveUp = false; break;
        case 'ShiftLeft': case 'KeyC': moveDown = false; break;
      }
    };
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    // --- Mobile Touch Controls ---
    if (isMobile) {
        const moveStick = document.getElementById('joystick-move-handle');
        const moveZone = document.getElementById('joystick-move-zone');
        const upBtn = document.getElementById('move-up-btn');
        const downBtn = document.getElementById('move-down-btn');
        const interactBtn = document.getElementById('interact-btn');

        let moveTouchId = -1;
        let lookTouchId = -1;
        let lookStart = { x: 0, y: 0 };
        const moveStickRadius = moveZone.offsetWidth / 2;

        moveZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            moveTouchId = e.changedTouches[0].identifier;
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for(let i=0; i < e.changedTouches.length; i++){
                const touch = e.changedTouches[i];
                if (touch.identifier === moveTouchId) {
                    const rect = moveZone.getBoundingClientRect();
                    const x = touch.clientX - (rect.left + moveStickRadius);
                    const y = touch.clientY - (rect.top + moveStickRadius);
                    const dist = Math.min(Math.sqrt(x*x + y*y), moveStickRadius - 30);
                    const angle = Math.atan2(y, x);

                    moveStick.style.transform = `translate(${Math.cos(angle) * dist - 30}px, ${Math.sin(angle) * dist - 30}px)`;

                    const deadzone = 0.1;
                    const normalizedX = x / moveStickRadius;
                    const normalizedY = y / moveStickRadius;

                    moveForward = normalizedY < -deadzone;
                    moveBackward = normalizedY > deadzone;
                    moveLeft = normalizedX < -deadzone;
                    moveRight = normalizedX > deadzone;
                } else if(touch.identifier === lookTouchId) {
                    const deltaX = touch.clientX - lookStart.x;
                    const deltaY = touch.clientY - lookStart.y;
                    cameraLookSpeed.x = deltaX * 0.002;
                    cameraLookSpeed.y = deltaY * 0.002;
                    lookStart.x = touch.clientX;
                    lookStart.y = touch.clientY;
                }
            }
        }, { passive: false });
        
        document.addEventListener('touchstart', (e) => {
             for(let i=0; i < e.changedTouches.length; i++){
                const touch = e.changedTouches[i];
                if (touch.clientX > window.innerWidth / 2 && moveTouchId !== touch.identifier) {
                    if (lookTouchId === -1) {
                        lookTouchId = touch.identifier;
                        lookStart.x = touch.clientX;
                        lookStart.y = touch.clientY;
                    }
                }
            }
        });

        document.addEventListener('touchend', (e) => {
            for(let i=0; i < e.changedTouches.length; i++){
                const touch = e.changedTouches[i];
                if (touch.identifier === moveTouchId) {
                    moveTouchId = -1;
                    moveStick.style.transform = `translate(-50%, -50%)`;
                    moveForward = moveBackward = moveLeft = moveRight = false;
                } else if(touch.identifier === lookTouchId) {
                    lookTouchId = -1;
                }
            }
        });

        upBtn.addEventListener('touchstart', () => moveUp = true);
        upBtn.addEventListener('touchend', () => moveUp = false);
        downBtn.addEventListener('touchstart', () => moveDown = true);
        downBtn.addEventListener('touchend', () => moveDown = false);
        interactBtn.addEventListener('click', () => {
            if (intersectedObject) openModalForObject(intersectedObject);
        });
    }

    // --- Environment ---
    // --- Sun ---
    const sunPosition = new THREE.Vector3(200, 75, -500);
    const sunGeo = new THREE.SphereGeometry(50, 32, 16); // Optimization: Reduced segments
    const sunMaterial = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uColor1: { value: new THREE.Color(0xffe8ab) },
            uColor2: { value: new THREE.Color(0xff8c00) },
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float uTime;
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            varying vec2 vUv;

            // 2D Noise function
            float random (vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            // 2D Noise based on Morgan McGuire @morgan3d
            float noise (vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);

                float a = random(i);
                float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0));
                float d = random(i + vec2(1.0, 1.0));

                vec2 u = f*f*(3.0-2.0*f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }

            void main() {
                float dist = distance(vUv, vec2(0.5));
                
                // Turbulent surface
                float t = uTime * 0.1;
                float n = noise(vUv * 5.0 + t) * 0.5 + noise(vUv * 10.0 - t) * 0.25;
                
                // Create a glowing core
                float core = 1.0 - smoothstep(0.0, 0.5, dist);
                
                // Mix colors based on noise and distance
                vec3 color = mix(uColor1, uColor2, n);
                
                // Corona effect
                float corona = smoothstep(0.45, 0.6, dist);
                corona = 1.0 - corona;
                
                // Final color
                vec3 finalColor = color * core + uColor1 * corona * 0.5;
                
                // Fade out at the edges
                float alpha = 1.0 - smoothstep(0.48, 0.5, dist);

                gl_FragColor = vec4(finalColor, alpha);
            }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
    });
    const sun = new THREE.Mesh(sunGeo, sunMaterial);
    sun.position.copy(sunPosition);
    scene.add(sun);
    
    // Add a point light for a subtle glow on other objects
    const sunLight = new THREE.PointLight(0xffd185, 2, 2000, 1);
    sunLight.position.copy(sunPosition);
    scene.add(sunLight);


    // --- Fractal Background ---
    const fractalGeo = new THREE.SphereGeometry(1500, 32, 16); // Optimization: Reduced segments
    const fractalMaterial = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            uSunDirection: { value: new THREE.Vector3().copy(sunPosition).normalize() }
        },
        vertexShader: `
            varying vec3 vWorldDirection;

            void main() {
                vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                vWorldDirection = worldPosition.xyz - cameraPosition;
                gl_Position = projectionMatrix * viewMatrix * worldPosition;
            }
        `,
        fragmentShader: `
            uniform float uTime;
            uniform vec3 uSunDirection;
            varying vec3 vWorldDirection;

            const int MAX_STEPS = 32; // Optimization: Reduced raymarching steps
            const float MAX_DIST = 100.0;
            const float SURF_DIST = 0.001;

            float mandelbulbSDF(vec3 pos, float time) {
                vec3 z = pos;
                float dr = 1.0;
                float r = 0.0;
                float power = 8.0 + sin(time * 0.1) * 2.0; 

                for (int i = 0; i < 5; i++) {
                    r = length(z);
                    if (r > 2.0) break;

                    float theta = acos(z.z / r);
                    float phi = atan(z.y, z.x);
                    dr = pow(r, power - 1.0) * power * dr + 1.0;

                    float zr = pow(r, power);
                    theta = theta * power;
                    phi = phi * power;

                    z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
                    z += pos;
                }
                return 0.5 * log(r) * r / dr;
            }

            float map(vec3 p) {
                float d = mandelbulbSDF(p * 0.5, uTime);
                return d * 0.8;
            }

            vec3 getNormal(vec3 p) {
                float d = map(p);
                vec2 e = vec2(0.001, 0);
                vec3 n = d - vec3(
                    map(p - e.xyy),
                    map(p - e.yxy),
                    map(p - e.yyx)
                );
                return normalize(n);
            }
            
            float rayMarch(vec3 ro, vec3 rd) {
                float dO = 0.0;
                for(int i = 0; i < MAX_STEPS; i++) {
                    vec3 p = ro + rd * dO;
                    float dS = map(p);
                    dO += dS;
                    if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;
                }
                return dO;
            }

            vec3 palette(float t) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.2, 0.4, 0.8);
                return a + b * cos(6.28318 * (c * t + d));
            }

            void main() {
                vec3 ro = cameraPosition;
                vec3 rd = normalize(vWorldDirection);

                float dist = rayMarch(ro, rd);
                
                if (dist > MAX_DIST) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // Black background
                    return;
                }
                
                vec3 p = ro + rd * dist;
                vec3 n = getNormal(p);
                
                float light = dot(n, uSunDirection);
                
                float color_t = length(p) * 0.1 + uTime * 0.05;
                vec3 col = palette(color_t);
                col = col * (0.5 + 0.5 * light);
                col = mix(col, vec3(0.0), 1.0 - exp(-0.0005 * dist * dist)); // Fog

                gl_FragColor = vec4(col, 1.0);
            }
        `,
        side: THREE.BackSide,
        depthWrite: false
    });
    const fractalBackground = new THREE.Mesh(fractalGeo, fractalMaterial);
    scene.add(fractalBackground);

    // --- Wormhole Tunnel ---
    function createWormhole() {
        // 1. Create a curve
        const path = new THREE.CatmullRomCurve3([
            new THREE.Vector3(100, 0, -100),
            new THREE.Vector3(50, 20, -200),
            new THREE.Vector3(0, 0, -300),
            new THREE.Vector3(-50, -20, -400),
            new THREE.Vector3(-100, 0, -500),
            new THREE.Vector3(-50, 20, -600),
            new THREE.Vector3(0, 0, -700),
            new THREE.Vector3(50, -20, -800),
            new THREE.Vector3(100, 0, -900),
        ]);

        // 2. Create geometry
        const tubeGeo = new THREE.TubeGeometry(path, 80, 20, 12, false); // Optimization: Reduced segments

        // 3. Create shader material
        const wormholeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor1: { value: new THREE.Color(0x3b82f6) },
                uColor2: { value: new THREE.Color(0x8b5cf6) },
            },
            vertexShader: `
                uniform float uTime;
                varying vec2 vUv;

                // Perlin 3D noise
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                float snoise(vec3 v) {
                    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i  = floor(v + dot(v, C.yyy) );
                    vec3 x0 =   v - i + dot(i, C.xxx) ;
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min( g.xyz, l.zxy );
                    vec3 i2 = max( g.xyz, l.zxy );
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute( permute( permute(
                                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                    float n_ = 0.142857142857;
                    vec3  ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_ );
                    vec4 x = x_ *ns.x + ns.yyyy;
                    vec4 y = y_ *ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4( x.xy, y.xy );
                    vec4 b1 = vec4( x.zw, y.zw );
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                    p0 *= norm.x;
                    p1 *= norm.y;
                    p2 *= norm.z;
                    p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
                }

                void main() {
                    vUv = uv;
                    vec3 pos = position;
                    float noise = snoise(pos * 0.1 + uTime * 0.2) * 2.0;
                    pos += normal * noise;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                varying vec2 vUv;

                float random (vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);
                    float a = random(i);
                    float b = random(i + vec2(1.0, 0.0));
                    float c = random(i + vec2(0.0, 1.0));
                    float d = random(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                }

                void main() {
                    vec2 uv = vUv;
                    uv.x -= uTime * 0.1;

                    float n = noise(uv * vec2(10.0, 2.0)) * 0.5 + noise(uv * vec2(20.0, 4.0)) * 0.25;
                    n = pow(n, 2.0);

                    vec3 color = mix(uColor1, uColor2, n);
                    
                    float streaks = sin((uv.y - uTime * 0.05) * 50.0) * 0.5 + 0.5;
                    streaks = smoothstep(0.8, 1.0, streaks);
                    color += vec3(1.0, 1.0, 1.0) * streaks * 0.5;

                    float edgeFade = smoothstep(0.0, 0.1, vUv.y) * smoothstep(1.0, 0.9, vUv.y);
                    
                    float alpha = n * 1.5 + streaks;

                    gl_FragColor = vec4(color, alpha * edgeFade);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            depthWrite: false,
        });
        
        const wormhole = new THREE.Mesh(tubeGeo, wormholeMaterial);
        scene.add(wormhole);
        return wormhole;
    }
    const wormhole = createWormhole();

    // --- Fractal Planet ---
    function createFractalPlanet() {
        const planetGeo = new THREE.SphereGeometry(800, 32, 16); // Optimization: Reduced segments
        const planetMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uSunDirection: { value: new THREE.Vector3().copy(sunPosition).normalize() }
            },
            vertexShader: `
                varying vec3 vWorldDirection;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
                    vWorldDirection = worldPosition.xyz - cameraPosition;
                    gl_Position = projectionMatrix * viewMatrix * worldPosition;
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uSunDirection;
                varying vec3 vWorldDirection;

                const int MAX_STEPS = 48; // Optimization: Reduced raymarching steps
                const float MAX_DIST = 1000.0;
                const float SURF_DIST = 0.01;

                // --- Noise Function (Simplex) ---
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i = floor(v + dot(v, C.yyy));
                    vec3 x0 = v - i + dot(i, C.xxx);
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min(g.xyz, l.zxy);
                    vec3 i2 = max(g.xyz, l.zxy);
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                    float n_ = 0.142857142857;
                    vec3 ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_);
                    vec4 x = x_ *ns.x + ns.yyyy;
                    vec4 y = y_ *ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4(x.xy, y.xy);
                    vec4 b1 = vec4(x.zw, y.zw);
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
                }
                
                // --- Fractal Brownian Motion for Terrain ---
                float fbm(vec3 p) {
                    float v = 0.0;
                    float a = 0.5;
                    vec3 shift = vec3(100.0);
                    for (int i = 0; i < 5; ++i) { // Optimization: Reduced octaves
                        v += a * snoise(p);
                        p = p * 2.0 + shift;
                        a *= 0.5;
                    }
                    return v;
                }

                // --- SDFs (Signed Distance Functions) ---
                float sdCylinder(vec3 p, float h, float r) {
                    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
                    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
                }
                
                float sdFractalTree(vec3 p) {
                    float d = 1e10;
                    p.y -= 30.0; // Raise tree a bit
                    vec3 p_orig = p;
                    float scale = 1.0;
                    mat2 rot = mat2(cos(0.8), -sin(0.8), sin(0.8), cos(0.8));

                    for (int i = 0; i < 5; i++) { // Optimization: Reduced iterations
                        p.y -= 2.0 * scale;
                        p.xz = abs(p.xz);
                        p.xz -= 1.0 * scale;
                        p.xz *= rot;
                        d = min(d, sdCylinder(p, 5.0 * scale, 0.2 * scale));
                        scale *= 0.8;
                    }
                    return d;
                }

                vec2 opRep(vec3 p, vec3 c) {
                    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;
                    return vec2(sdFractalTree(q), 2.0);
                }

                // --- Main Scene Map ---
                vec2 map(vec3 p) {
                    // Ground / Mountains
                    float ground = p.y + fbm(p * 0.01) * 30.0;
                    vec2 res = vec2(ground, 1.0);

                    // Trees
                    vec2 tree = opRep(p, vec3(40.0, 0.0, 40.0));
                    tree.x += 0.01; // Make sure tree SDF is slightly positive at base
                    
                    if (tree.x < res.x) {
                       res = tree;
                    }

                    return res;
                }
                
                vec3 getNormal(vec3 p) {
                    vec2 e = vec2(0.01, 0);
                    vec3 n = map(p).x - vec3(
                        map(p - e.xyy).x,
                        map(p - e.yxy).x,
                        map(p - e.yyx).x
                    );
                    return normalize(n);
                }

                float rayMarch(vec3 ro, vec3 rd) {
                    float dO = 0.0;
                    for(int i = 0; i < MAX_STEPS; i++) {
                        vec3 p = ro + rd * dO;
                        float dS = map(p).x;
                        dO += dS;
                        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;
                    }
                    return dO;
                }

                // --- Main Render Function ---
                void main() {
                    vec3 ro = cameraPosition;
                    vec3 rd = normalize(vWorldDirection);
                    
                    float dist = rayMarch(ro, rd);
                    
                    if (dist > MAX_DIST) {
                        discard;
                    }
                    
                    vec3 p = ro + rd * dist;
                    vec3 n = getNormal(p);
                    vec2 res = map(p);
                    float materialID = res.y;

                    // --- Lighting ---
                    float sun_d = max(dot(n, uSunDirection), 0.0);
                    float ambient = 0.2;
                    float light = ambient + sun_d * 0.8;
                    
                    // --- Coloring ---
                    vec3 col;
                    if (materialID == 1.0) { // Ground
                        float height_factor = smoothstep(-20.0, 30.0, p.y);
                        vec3 rockColor = vec3(0.3);
                        vec3 snowColor = vec3(0.9);
                        col = mix(rockColor, snowColor, height_factor);
                    } else { // Trees
                        col = vec3(0.7, 0.8, 0.95) * 1.2;
                    }
                    
                    col *= light;
                    
                    // --- Fog ---
                    float fog_factor = 1.0 - exp(-0.002 * dist * dist);
                    col = mix(col, vec3(0.01, 0.02, 0.03), fog_factor);

                    gl_FragColor = vec4(col, 1.0);
                }
            `,
            side: THREE.BackSide,
        });
        const planet = new THREE.Mesh(planetGeo, planetMaterial);
        planet.position.set(0, 0, -1100);
        scene.add(planet);
        return planet;
    }

    const fractalPlanet = createFractalPlanet();


    // --- Companion Sphere ---
    const companionGeo = new THREE.SphereGeometry(1, 24, 12); // Optimization: Reduced segments
    const companionMaterial = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uSpeed: { value: 0 },
            uColor: { value: new THREE.Color(0x8b5cf6) }
        },
        vertexShader: `
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldPosition;

            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = vec3(modelViewMatrix * vec4(position, 1.0));
                vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float uTime;
            uniform float uSpeed;
            uniform vec3 uColor;

            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vWorldPosition;

            float simpleNoise(vec3 p, float speed) {
                float time = uTime * (1.0 + speed * 2.0);
                return sin(p.x * 10.0 + time) *
                       sin(p.y * 10.0 + time) *
                       sin(p.z * 10.0 + time);
            }

            void main() {
                // Fresnel for edge glow
                vec3 viewDirection = normalize(-vPosition);
                float fresnel = 1.0 - dot(viewDirection, vNormal);
                fresnel = pow(fresnel, 4.0) * (1.5 + uSpeed * 5.0); // Glow more with speed

                // Core pulse
                float core = 1.0 - length(vPosition);
                core = smoothstep(0.6, 1.0, core);
                core *= (0.5 + sin(uTime * 5.0) * 0.5);

                // Surface energy pattern
                float noise = simpleNoise(vWorldPosition * 0.5, uSpeed);
                noise = smoothstep(0.2, 0.8, noise);

                // Combine
                vec3 finalColor = uColor * (noise * 0.5 + fresnel + core * 0.5);
                float alpha = clamp(fresnel + noise * 0.1 + core * 0.2, 0.0, 1.0);

                gl_FragColor = vec4(finalColor, alpha);
            }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    const companionSphere = new THREE.Mesh(companionGeo, companionMaterial);
    scene.add(companionSphere);

    const companionTarget = new THREE.Object3D();
    camera.add(companionTarget);
    companionTarget.position.set(2.5, 1, -5);


    // --- Interactive Portals ---
    const interactiveObjects = [];
    function createPortal(text, position, color, dataKey) {
        const group = new THREE.Group();
        group.userData.color = new THREE.Color(color);

        // --- Custom Shader Material for Portals ---
        const vertexShader = `
            varying vec3 vNormal;
            varying vec3 vPosition; // Position in view space

            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = vec3(modelViewMatrix * vec4(position, 1.0));
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColor;
            uniform float uTime;

            varying vec3 vNormal;
            varying vec3 vPosition;

            void main() {
                // Fresnel effect for edge glow
                vec3 viewDirection = normalize(-vPosition);
                float fresnel = 1.0 - dot(viewDirection, vNormal);
                fresnel = pow(fresnel, 3.0); // Power of 3.0 for a tight glow

                // Simple animated bands for energy effect
                float bands = sin(vPosition.y * 15.0 - uTime * 3.0) * 0.5 + 0.5;
                float energy = smoothstep(0.45, 0.55, bands);

                // Combine effects
                float intensity = fresnel * 1.5 + energy * 0.3;
                float alpha = pow(fresnel, 2.0) + energy * 0.2;

                gl_FragColor = vec4(uColor * intensity, alpha);
            }
        `;
        
        const portalMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uColor: { value: new THREE.Color(color) },
            },
            vertexShader,
            fragmentShader,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        group.userData.material = portalMaterial; // Store material to update uniforms

        const mainRingGeo = new THREE.TorusGeometry(5, 0.2, 16, 48); // Optimization: Reduced segments
        const mainRing = new THREE.Mesh(mainRingGeo, portalMaterial);

        const innerRingGeo = new THREE.TorusGeometry(4.2, 0.1, 16, 48); // Optimization: Reduced segments
        const innerRing = new THREE.Mesh(innerRingGeo, portalMaterial); // Share the same material
        innerRing.rotation.x = Math.PI / 2;
        
        const coreGeo = new THREE.SphereGeometry(0.5, 16, 8); // Optimization: Reduced segments
        const coreMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
        const core = new THREE.Mesh(coreGeo, coreMat);
        
        mainRing.userData = { isInteractive: true, dataKey };
        
        const labelDiv = document.createElement('div');
        labelDiv.className = 'css2d-label';
        labelDiv.textContent = text;
        const label = new CSS2DObject(labelDiv);
        label.position.set(0, 6.5, 0);

        group.add(mainRing, innerRing, core, label);
        group.position.copy(position);
        scene.add(group);
        interactiveObjects.push(mainRing);
        return group;
    }

    const portals = [
        createPortal('Трюки', new THREE.Vector3(0, 0, -40), 0x3b82f6, 'tricks'),
        createPortal('Инструкторы', new THREE.Vector3(-40, 10, 0), 0x8b5cf6, 'instructors'),
        createPortal('Расписание', new THREE.Vector3(40, -10, 0), 0x10b981, 'schedule'),
        createPortal('Контакты', new THREE.Vector3(0, -5, 50), 0xf59e0b, 'contact'),
    ];

    // --- Raycasting for Interaction ---
    const raycaster = new THREE.Raycaster();
    const crosshair = document.querySelector('.crosshair');
    const interactionPrompt = document.querySelector('.interaction-prompt');
    const interactionText = document.getElementById('interaction-text');
    const interactBtnMobile = document.getElementById('interact-btn');
    let intersectedObject = null;

    // --- Animation Loop ---
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      // Update Sun
      sunMaterial.uniforms.uTime.value = time;

      // Update Fractal Background
      fractalMaterial.uniforms.uTime.value = time;

      // Update Fractal Planet
      fractalPlanet.material.uniforms.uTime.value = time;

      // Update Wormhole
      wormhole.material.uniforms.uTime.value = time;

      // Update Portals
      portals.forEach((p, i) => {
        p.children[0].rotation.y += 0.003; // mainRing
        p.children[1].rotation.y -= 0.008; // innerRing
        p.children[1].rotation.x += 0.003;
        
        // Update shader uniforms on the shared material
        p.userData.material.uniforms.uTime.value = time;
        
        const pulse = 1 + Math.sin(time * 2 + i) * 0.05;
        p.scale.set(pulse, pulse, pulse);
        
        const intensity = 0.8 + Math.sin(time * 3 + i) * 0.2;
        const color = p.userData.color.clone().multiplyScalar(intensity);
        
        // Update shader color uniform
        p.userData.material.uniforms.uColor.value.copy(color);

        // Update core color
        p.children[2].material.color.copy(color);
      });

      // Update controls and movement
      const speed = 80.0;
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.y -= velocity.y * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;
      
      direction.z = Number(moveForward) - Number(moveBackward);
      direction.x = Number(moveRight) - Number(moveLeft);
      direction.normalize();

      if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
      if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
      if (moveUp) velocity.y += speed * delta;
      if (moveDown) velocity.y -= speed * delta;
      
      if (isMobile) {
          camera.rotation.y -= cameraLookSpeed.x;
          camera.rotation.x -= cameraLookSpeed.y;
          camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
          cameraLookSpeed.x = 0;
          cameraLookSpeed.y = 0;

          const euler = new THREE.Euler(0, camera.rotation.y, 0, 'YXZ');
          const forward = new THREE.Vector3(0, 0, -1).applyEuler(euler);
          const right = new THREE.Vector3(1, 0, 0).applyEuler(euler);

          camera.position.addScaledVector(forward, -velocity.z * delta);
          camera.position.addScaledVector(right, -velocity.x * delta);
          camera.position.y += velocity.y * delta;

      } else if (controls.isLocked) {
          controls.moveRight(-velocity.x * delta);
          controls.moveForward(-velocity.z * delta);
          controls.getObject().position.y += velocity.y * delta;
      }

      // Update Companion Sphere
      const targetPosition = new THREE.Vector3();
      companionTarget.getWorldPosition(targetPosition);

      companionSphere.position.lerp(targetPosition, 0.03); // Smooth follow

      // Add bobbing motion
      companionSphere.position.y += Math.sin(time * 2.5) * 0.02;
      companionSphere.position.x += Math.cos(time * 2.0) * 0.02;

      // Look at the player
      companionSphere.lookAt(camera.position);

      // Update shader
      companionSphere.material.uniforms.uTime.value = time;
      const currentSpeed = velocity.length();
      companionSphere.material.uniforms.uSpeed.value = Math.min(currentSpeed / speed, 1.0);


      // Interaction Raycast
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      const intersects = raycaster.intersectObjects(interactiveObjects);
      
      if (intersects.length > 0 && intersects[0].distance < 15) {
          if (intersectedObject !== intersects[0].object) {
              intersectedObject = intersects[0].object;
          }
          if(isMobile){
            interactBtnMobile.classList.remove('hidden');
          } else {
            crosshair.classList.add('interactive');
            interactionPrompt.classList.add('visible');
            interactionText.textContent = `Взаимодействовать с "${intersects[0].object.parent.children[3].element.textContent}"`;
          }
      } else {
          intersectedObject = null;
          if(isMobile){
            interactBtnMobile.classList.add('hidden');
          } else {
            crosshair.classList.remove('interactive');
            interactionPrompt.classList.remove('visible');
          }
      }

      composer.render();
      labelRenderer.render(scene, camera);
    }

    // --- Window Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      fractalMaterial.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
    });

    // --- Modal Logic & Data ---
    const modalContainer = document.getElementById('modal-container');
    const modalContent = document.getElementById('modal-content');

    const appData = {
      tricks: [
        { name: '540 Kick', difficulty: 'Новичок', description: 'Вращение на 540° с ударом ногой в воздухе. Основа для многих продвинутых трюков.' },
        { name: 'Butterfly Kick (B-Kick)', difficulty: 'Новичок', description: 'Горизонтальное вращение с махом ногами, похожее на крылья бабочки.' },
        { name: 'Gainer', difficulty: 'Средний', description: 'Сальто назад с движением вперёд. Часто выполняется с возвышения.' },
        { name: 'Corkscrew (Cork)', difficulty: 'Средний', description: 'Горизонтальный винт в воздухе, сочетающий сальто и вращение. Выглядит очень эффектно.' },
        { name: 'Double Cork', difficulty: 'Продвинутый', description: 'Corkscrew с двумя полными винтами в воздухе. Требует высоты и контроля.' },
        { name: 'Cartwheel Full Twist', difficulty: 'Продвинутый', description: 'Колесо, переходящее в сальто назад с винтом. Динамичный и красивый элемент.' }
      ],
      instructors: [
        { name: 'Дмитрий "Вихрь" Петров', specialty: 'Силовые элементы и сальто', bio: 'Мастер акробатики, который научит вас летать. Дмитрий верит, что нет ничего невозможного.' },
        { name: 'Елена "Стрела" Волкова', specialty: 'Гибкость и кикинг', bio: 'Ее удары ногами - это искусство. Елена поможет вам развить грацию, скорость и невероятную гибкость.' },
        { name: 'Иван "Метеор" Соколов', specialty: 'Комбо и переходы', bio: 'Гуру плавных связок и креативных переходов. Иван научит вас создавать свой уникальный стиль.' },
      ],
      schedule: [
        { day: 'Понедельник', time: '18:00 - 19:30', className: 'Основы Трикинга', level: 'Новичок' },
        { day: 'Вторник', time: '19:00 - 20:30', className: 'Продвинутые Кики', level: 'Средний' },
        { day: 'Среда', time: '18:00 - 19:30', className: 'Акробатика', level: 'Все уровни' },
        { day: 'Четверг', time: '20:00 - 21:30', className: 'Комбо-сессия', level: 'Продвинутый' },
        { day: 'Пятница', time: '19:00 - 20:30', className: 'Открытый Зал', level: 'Все уровни' },
        { day: 'Суббота', time: '12:00 - 14:00', className: 'Интенсив по Сальто', level: 'Средний/Продвинутый' },
      ]
    };

    function getDifficultyClass(level) {
        return `difficulty-${level.replace(' ', '_').replace('/', '\\/')}`;
    }

    function openModalForObject(object) {
        if (!isMobile) {
          controls.unlock();
        }
        const dataKey = object.userData.dataKey;
        let contentHTML = `
            <button id="modal-close" class="modal-close-btn" aria-label="Закрыть">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        `;

        switch(dataKey) {
            case 'tricks':
                contentHTML += `<h2 class="section-title">Библиотека Трюков</h2>`;
                contentHTML += appData.tricks.map(trick => `
                    <div class="card">
                        <div class="flex justify-between items-start">
                           <h3 class="text-xl font-bold mb-2 text-gray-100">${trick.name}</h3>
                           <span class="get-difficulty-class ${getDifficultyClass(trick.difficulty)}">${trick.difficulty}</span>
                        </div>
                        <p class="text-gray-400">${trick.description}</p>
                    </div>
                `).join('');
                break;
            case 'instructors':
                contentHTML += `<h2 class="section-title">Наши Инструкторы</h2>`;
                contentHTML += appData.instructors.map(ins => `
                    <div class="card text-center">
                        <h3 class="text-xl font-bold text-gray-100">${ins.name}</h3>
                        <p class="text-purple-400 mt-1 font-semibold">${ins.specialty}</p>
                        <p class="text-gray-400 mt-2">${ins.bio}</p>
                    </div>
                `).join('');
                break;
            case 'schedule':
                contentHTML += `<h2 class="section-title">Расписание</h2>`;
                contentHTML += `<div class="overflow-x-auto"><table class="w-full text-left"><thead><tr class="border-b border-gray-700">
                    <th class="p-3">День</th><th class="p-3">Время</th><th class="p-3">Занятие</th><th class="p-3">Уровень</th>
                    </tr></thead><tbody>`;
                contentHTML += appData.schedule.map(item => `
                    <tr class="border-b border-gray-800 hover:bg-gray-800/50">
                        <td class="p-3 font-semibold text-gray-200">${item.day}</td>
                        <td class="p-3 text-gray-300">${item.time}</td>
                        <td class="p-3 text-gray-300">${item.className}</td>
                        <td class="p-3"><span class="get-difficulty-class ${getDifficultyClass(item.level)}">${item.level}</span></td>
                    </tr>
                `).join('');
                contentHTML += `</tbody></table></div>`;
                break;
            case 'contact':
                contentHTML += `<h2 class="section-title">Контакты</h2>`;
                contentHTML += `<div class="card text-center text-lg">
                    <p class="text-xl text-gray-200 mb-4">Готов начать? Первое занятие бесплатно!</p>
                    <p class="text-gray-300"><strong>Адрес:</strong> г. Москва, ул. Спортивная, 1</p>
                    <p class="text-gray-300 mt-1"><strong>Телефон:</strong> +7 (495) 123-45-67</p>
                </div>`;
                break;
        }

        modalContent.innerHTML = contentHTML;
        modalContent.scrollTop = 0; // Reset scroll position
        modalContainer.classList.add('visible');

        document.getElementById('modal-close').addEventListener('click', closeModal);
        modalContainer.addEventListener('click', (e) => {
            if (e.target === modalContainer) closeModal();
        });
    }
    
    function closeModal() {
        modalContainer.classList.remove('visible');
    }

    // Start the animation loop
    animate();
  </script>
</body>
</html>
